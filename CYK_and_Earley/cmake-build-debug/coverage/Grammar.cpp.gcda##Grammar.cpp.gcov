        -:    0:Source:/Users/sadovinama/CLionProjects/formal_practice/CYK_and_Earley/src/Grammar.cpp
        -:    0:Graph:/Users/sadovinama/CLionProjects/formal_practice/CYK_and_Earley/cmake-build-debug/CMakeFiles/unit_tests.dir/src/Grammar.cpp.gcno
        -:    0:Data:/Users/sadovinama/CLionProjects/formal_practice/CYK_and_Earley/cmake-build-debug/CMakeFiles/unit_tests.dir/src/Grammar.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "Grammar.h"
        -:    2:
function _ZN7Grammar14first_step_CNFEv called 10 returned 0% blocks executed 92%
       10:    3:void Grammar::first_step_CNF() { // delete non generative symbols
       10:    3-block  0
       10:    4:    std::set<int> non_generative;
       43:    5:    for(auto nonterm : nonterminals) {
       10:    5-block  0
       43:    5-block  1
branch  0 taken 43
branch  1 taken 0
       43:    5-block  2
branch  2 taken 33
branch  3 taken 10
       33:    5-block  3
branch  4 taken 33
branch  5 taken 0
       33:    5-block  4
       33:    5-block  5
branch  6 taken 33
branch  7 taken 0
       33:    5-block  6
       33:    6:        if (!is_generative(nonterm)) {
       33:    6-block  0
branch  0 taken 33
branch  1 taken 0
       33:    6-block  1
branch  2 taken 23
branch  3 taken 10
       10:    7:            non_generative.insert(nonterm);
       10:    7-block  0
branch  0 taken 10
branch  1 taken 0
       10:    8:        }
       10:    8-block  0
        -:    9:    }
       20:   10:    for(auto nonterm: non_generative) {
       10:   10-block  0
       20:   10-block  1
branch  0 taken 20
branch  1 taken 0
       20:   10-block  2
branch  2 taken 10
branch  3 taken 10
       10:   10-block  3
branch  4 taken 10
branch  5 taken 0
       10:   10-block  4
       10:   10-block  5
branch  6 taken 10
branch  7 taken 0
       10:   10-block  6
       10:   11:        transitions.erase(nonterm);
       10:   11-block  0
branch  0 taken 10
branch  1 taken 0
       10:   12:        nonterminals.erase(nonterm);
       10:   12-block  0
branch  0 taken 10
branch  1 taken 0
        -:   13:    }
       34:   14:    for(auto& rule: transitions) {
       10:   14-block  0
       34:   14-block  1
branch  0 taken 34
branch  1 taken 0
       34:   14-block  2
branch  2 taken 24
branch  3 taken 10
       24:   14-block  3
branch  4 taken 24
branch  5 taken 0
       24:   14-block  4
       24:   14-block  5
branch  6 taken 24
branch  7 taken 0
       24:   14-block  6
       24:   15:        std::set<std::vector<int>> erase_word;
       70:   16:        for(auto& word: rule.second) {
       24:   16-block  0
       70:   16-block  1
branch  0 taken 70
branch  1 taken 0
       70:   16-block  2
branch  2 taken 46
branch  3 taken 24
       46:   16-block  3
branch  4 taken 46
branch  5 taken 0
       46:   16-block  4
       46:   16-block  5
branch  6 taken 46
branch  7 taken 0
       46:   16-block  6
      130:   17:            for(auto letter: word) {
       46:   17-block  0
      130:   17-block  1
branch  0 taken 92
branch  1 taken 38
       84:   17-block  2
       84:   17-block  3
       92:   18:                if(non_generative.contains(letter)) {
       92:   18-block  0
branch  0 taken 92
branch  1 taken 0
       92:   18-block  1
branch  2 taken 8
branch  3 taken 84
        8:   19:                    erase_word.insert(word);
        8:   19-block  0
branch  0 taken 8
branch  1 taken 0
        8:   20:                    break;
        8:   20-block  0
        -:   21:                }
        -:   22:            }
        -:   23:        }
       32:   24:        for(auto& elem: erase_word) {
       24:   24-block  0
       32:   24-block  1
branch  0 taken 32
branch  1 taken 0
       32:   24-block  2
branch  2 taken 8
branch  3 taken 24
        8:   24-block  3
branch  4 taken 8
branch  5 taken 0
        8:   24-block  4
        8:   24-block  5
branch  6 taken 8
branch  7 taken 0
        8:   24-block  6
        8:   25:            rule.second.erase(elem);
        8:   25-block  0
branch  0 taken 8
branch  1 taken 0
        -:   26:        }
       24:   27:    }
    $$$$$:   27-block  0
       10:   28:}
    $$$$$:   28-block  0
       10:   28-block  1
    $$$$$:   28-block  2
    $$$$$:   28-block  3
        -:   29:
function _ZN7Grammar13is_generativeEi called 92 returned 100% blocks executed 100%
       92:   30:bool Grammar::is_generative(int nonterm) {
       92:   30-block  0
       92:   31:    bool ans = true;
      104:   32:    for(const auto& word : transitions[nonterm]) {
       92:   32-block  0
      104:   32-block  1
branch  0 taken 92
branch  1 taken 12
       12:   32-block  2
       12:   32-block  3
       92:   33:        ans = true;
      268:   34:        for(auto letter : word) {
       92:   34-block  0
      268:   34-block  1
branch  0 taken 176
branch  1 taken 92
      176:   34-block  2
      176:   34-block  3
      176:   35:            if(letter == nonterm || (nonterminals.contains(letter) && !is_generative(letter))) {
      176:   35-block  0
branch  0 taken 10
branch  1 taken 166
      166:   35-block  1
branch  2 taken 59
branch  3 taken 107
       59:   35-block  2
branch  4 taken 57
branch  5 taken 2
       12:   36:                ans = false;
       12:   37:            }
       12:   37-block  0
        -:   38:        }
       92:   39:        if(ans) {
       92:   39-block  0
branch  0 taken 80
branch  1 taken 12
       80:   40:            return true;
       80:   40-block  0
        -:   41:        }
        -:   42:    }
       12:   43:    return false;
       12:   43-block  0
       92:   44:}
       92:   44-block  0
        -:   45:
function _ZN7Grammar13is_achievableEii called 49 returned 100% blocks executed 100%
       49:   46:bool Grammar::is_achievable(int begin, int nonterm) {
       49:   46-block  0
       49:   47:    if (begin == nonterm) {
       49:   47-block  0
branch  0 taken 30
branch  1 taken 19
       30:   48:        return true;
       30:   48-block  0
        -:   49:    }
       19:   50:    bool ans = false;
       44:   51:    for(auto& word: transitions[begin]) {
       19:   51-block  0
       44:   51-block  1
branch  0 taken 25
branch  1 taken 19
       25:   51-block  2
       25:   51-block  3
       25:   52:        int num_eps = 0;
       92:   53:        for(auto letter: word) {
       25:   53-block  0
       92:   53-block  1
branch  0 taken 67
branch  1 taken 25
       61:   53-block  2
       67:   53-block  3
       67:   54:            if(letter == begin) {
       67:   54-block  0
branch  0 taken 6
branch  1 taken 61
        6:   55:                continue;
        6:   55-block  0
        -:   56:            }
       61:   57:            if(letter == eps) {
       61:   57-block  0
branch  0 taken 6
branch  1 taken 55
        6:   58:                ++num_eps;
        6:   59:            }
        6:   59-block  0
       61:   60:            if(nonterminals.contains(letter) && is_achievable(letter, nonterm)) {
       61:   60-block  0
branch  0 taken 26
branch  1 taken 35
       26:   60-block  1
branch  2 taken 20
branch  3 taken 6
       20:   61:                ans = true;
       20:   62:            }
       20:   62-block  0
        -:   63:        }
       25:   64:        if(num_eps == word.size()) {
       25:   64-block  0
branch  0 taken 6
branch  1 taken 19
        6:   65:            is_conclusion_eps = true;
        6:   66:        }
        6:   66-block  0
        -:   67:    }
       19:   68:    return ans;
       19:   68-block  0
       49:   69:}
       49:   69-block  0
        -:   70:
        -:   71://deleting unattainable symbols
function _ZN7Grammar15second_step_CNFEv called 10 returned 0% blocks executed 80%
       10:   72:void Grammar::second_step_CNF() {
       10:   72-block  0
       10:   73:    std::set<int> unattainable;
       33:   74:    for(auto nonterm: nonterminals) {
       10:   74-block  0
       33:   74-block  1
branch  0 taken 33
branch  1 taken 0
       33:   74-block  2
branch  2 taken 23
branch  3 taken 10
       23:   74-block  3
branch  4 taken 23
branch  5 taken 0
       23:   74-block  4
       23:   74-block  5
branch  6 taken 23
branch  7 taken 0
       23:   74-block  6
       23:   75:        if(!is_achievable(start, nonterm)) {
       23:   75-block  0
branch  0 taken 23
branch  1 taken 0
       23:   75-block  1
branch  2 taken 20
branch  3 taken 3
        3:   76:            unattainable.insert(nonterm);
        3:   76-block  0
branch  0 taken 3
branch  1 taken 0
        3:   77:        }
        3:   77-block  0
        -:   78:    }
       13:   79:    for(auto elem: unattainable) {
       10:   79-block  0
       13:   79-block  1
branch  0 taken 13
branch  1 taken 0
       13:   79-block  2
branch  2 taken 3
branch  3 taken 10
        3:   79-block  3
branch  4 taken 3
branch  5 taken 0
        3:   79-block  4
        3:   79-block  5
branch  6 taken 3
branch  7 taken 0
        3:   79-block  6
        3:   80:        transitions.erase(elem);
        3:   80-block  0
branch  0 taken 3
branch  1 taken 0
        3:   81:        nonterminals.erase(elem);
        3:   81-block  0
branch  0 taken 3
branch  1 taken 0
        -:   82:    }
       31:   83:    for(auto& rule: transitions) {
       10:   83-block  0
       31:   83-block  1
branch  0 taken 31
branch  1 taken 0
       31:   83-block  2
branch  2 taken 21
branch  3 taken 10
       21:   83-block  3
branch  4 taken 21
branch  5 taken 0
       21:   83-block  4
       21:   83-block  5
branch  6 taken 21
branch  7 taken 0
       21:   83-block  6
       21:   84:        std::set<std::vector<int>> erase_word;
       54:   85:        for(auto& word: rule.second) {
       21:   85-block  0
       54:   85-block  1
branch  0 taken 54
branch  1 taken 0
       54:   85-block  2
branch  2 taken 33
branch  3 taken 21
       33:   85-block  3
branch  4 taken 33
branch  5 taken 0
       33:   85-block  4
       33:   85-block  5
branch  6 taken 33
branch  7 taken 0
       33:   85-block  6
      110:   86:            for(auto letter: word) {
       33:   86-block  0
      110:   86-block  1
branch  0 taken 77
branch  1 taken 33
       77:   86-block  2
       77:   86-block  3
       77:   87:                if(unattainable.contains(letter)) {
       77:   87-block  0
branch  0 taken 77
branch  1 taken 0
       77:   87-block  1
branch  2 taken 0
branch  3 taken 77
    #####:   88:                    erase_word.insert(word);
    $$$$$:   88-block  0
branch  0 never executed
branch  1 never executed
    #####:   89:                    break;
    $$$$$:   89-block  0
        -:   90:                }
        -:   91:            }
        -:   92:        }
       21:   93:        for(auto& elem: erase_word) {
       21:   93-block  0
       21:   93-block  1
branch  0 taken 21
branch  1 taken 0
       21:   93-block  2
branch  2 taken 0
branch  3 taken 21
    $$$$$:   93-block  3
branch  4 never executed
branch  5 never executed
    $$$$$:   93-block  4
    $$$$$:   93-block  5
branch  6 never executed
branch  7 never executed
    $$$$$:   93-block  6
    #####:   94:            rule.second.erase(elem);
    $$$$$:   94-block  0
branch  0 never executed
branch  1 never executed
        -:   95:        }
       21:   96:    }
    $$$$$:   96-block  0
       10:   97:}
    $$$$$:   97-block  0
       10:   97-block  1
    $$$$$:   97-block  2
    $$$$$:   97-block  3
        -:   98:
        -:   99://deleting mixed rules
function _ZN7Grammar14third_step_CNFEv called 10 returned 0% blocks executed 87%
       10:  100:void Grammar::third_step_CNF() {
       10:  100-block  0
       10:  101:    std::set<std::pair<int, std::vector<int>>> insert_rules;
       31:  102:    for(auto& rule: transitions) {
       10:  102-block  0
       31:  102-block  1
branch  0 taken 31
branch  1 taken 0
       31:  102-block  2
branch  2 taken 21
branch  3 taken 10
       21:  102-block  3
branch  4 taken 21
branch  5 taken 0
       21:  102-block  4
       21:  102-block  5
branch  6 taken 21
branch  7 taken 0
       21:  102-block  6
       21:  103:        std::set<std::vector<int>> erase_word;
       21:  104:        std::set<std::vector<int>> insert_word;
       21:  105:        std::set<int> insert_nonterm;
       54:  106:        for(auto& word: rule.second) {
       21:  106-block  0
       54:  106-block  1
branch  0 taken 54
branch  1 taken 0
       54:  106-block  2
branch  2 taken 33
branch  3 taken 21
       33:  106-block  3
branch  4 taken 33
branch  5 taken 0
       20:  106-block  4
       33:  106-block  5
branch  6 taken 33
branch  7 taken 0
       33:  106-block  6
       33:  107:            if(word.size() < 2) {
       33:  107-block  0
branch  0 taken 13
branch  1 taken 20
       13:  108:                continue;
       13:  108-block  0
        -:  109:            }
       20:  110:            std::vector<int> terms;
       20:  111:            std::vector<int> nonterms;
       84:  112:            for(auto letter: word) {
       20:  112-block  0
       84:  112-block  1
branch  0 taken 64
branch  1 taken 20
       64:  112-block  2
       64:  112-block  3
       64:  113:                if(alpabet.contains(letter)) {
       64:  113-block  0
branch  0 taken 64
branch  1 taken 0
       64:  113-block  1
branch  2 taken 34
branch  3 taken 30
       34:  114:                    terms.push_back(letter);
       34:  114-block  0
branch  0 taken 34
branch  1 taken 0
       64:  115:                } else if(nonterminals.contains(letter)) {
       34:  115-block  0
       30:  115-block  1
branch  0 taken 30
branch  1 taken 0
       30:  115-block  2
branch  2 taken 30
branch  3 taken 0
       30:  116:                    nonterms.push_back(letter);
       30:  116-block  0
branch  0 taken 30
branch  1 taken 0
       30:  117:                }
       30:  117-block  0
        -:  118:            }
       20:  119:            std::vector<int> new_right_word;
       84:  120:            for(int i = 0; i < word.size(); ++i) {
       20:  120-block  0
       84:  120-block  1
branch  0 taken 64
branch  1 taken 20
       64:  120-block  2
       64:  121:                if(alpabet.contains(word[i])) {
       64:  121-block  0
branch  0 taken 64
branch  1 taken 0
       64:  121-block  1
branch  2 taken 34
branch  3 taken 30
       34:  122:                    int new_nonterm = std::max(*(alpabet.rbegin()) + 1 + i, *(nonterminals.rbegin()) + 1 + i);
       34:  122-block  0
branch  0 taken 34
branch  1 taken 0
       34:  122-block  1
branch  2 taken 34
branch  3 taken 0
       34:  122-block  2
branch  4 taken 34
branch  5 taken 0
       34:  123:                    new_right_word.push_back(new_nonterm);
       34:  123-block  0
branch  0 taken 34
branch  1 taken 0
       34:  124:                    insert_nonterm.insert(new_nonterm);
       34:  124-block  0
branch  0 taken 34
branch  1 taken 0
       34:  125:                    std::vector<int> letter_word = {word[i]};
       34:  125-block  0
branch  0 taken 34
branch  1 taken 0
       34:  126:                    insert_rules.insert({new_nonterm, letter_word});
       34:  126-block  0
branch  0 taken 34
branch  1 taken 0
       34:  126-block  1
branch  2 taken 34
branch  3 taken 0
    $$$$$:  126-block  2
       64:  127:                } else if(nonterminals.contains(word[i])) {
       34:  127-block  0
    $$$$$:  127-block  1
       30:  127-block  2
branch  0 taken 30
branch  1 taken 0
       30:  127-block  3
branch  2 taken 30
branch  3 taken 0
       30:  128:                    new_right_word.push_back(word[i]);
       30:  128-block  0
branch  0 taken 30
branch  1 taken 0
       30:  129:                }
       30:  129-block  0
       64:  130:            }
       64:  130-block  0
       20:  131:            insert_word.insert(new_right_word);
       20:  131-block  0
branch  0 taken 20
branch  1 taken 0
       20:  132:            erase_word.insert(word);
       20:  132-block  0
branch  0 taken 20
branch  1 taken 0
       20:  133:        }
    $$$$$:  133-block  0
    $$$$$:  133-block  1
       41:  134:        for(auto& elem: erase_word) {
       21:  134-block  0
       41:  134-block  1
branch  0 taken 41
branch  1 taken 0
       41:  134-block  2
branch  2 taken 20
branch  3 taken 21
       20:  134-block  3
branch  4 taken 20
branch  5 taken 0
       20:  134-block  4
       20:  134-block  5
branch  6 taken 20
branch  7 taken 0
       20:  134-block  6
       20:  135:            rule.second.erase(elem);
       20:  135-block  0
branch  0 taken 20
branch  1 taken 0
        -:  136:        }
       41:  137:        for(auto& elem: insert_word) {
       21:  137-block  0
       41:  137-block  1
branch  0 taken 41
branch  1 taken 0
       41:  137-block  2
branch  2 taken 20
branch  3 taken 21
       20:  137-block  3
branch  4 taken 20
branch  5 taken 0
       20:  137-block  4
       20:  137-block  5
branch  6 taken 20
branch  7 taken 0
       20:  137-block  6
       20:  138:            rule.second.insert(elem);
       20:  138-block  0
branch  0 taken 20
branch  1 taken 0
        -:  139:        }
       55:  140:        for(auto& elem: insert_nonterm) {
       21:  140-block  0
       55:  140-block  1
branch  0 taken 55
branch  1 taken 0
       55:  140-block  2
branch  2 taken 34
branch  3 taken 21
       34:  140-block  3
branch  4 taken 34
branch  5 taken 0
       34:  140-block  4
       34:  140-block  5
branch  6 taken 34
branch  7 taken 0
       34:  140-block  6
       34:  141:            nonterminals.insert(elem);
       34:  141-block  0
branch  0 taken 34
branch  1 taken 0
        -:  142:        }
       21:  143:    }
    $$$$$:  143-block  0
       44:  144:    for(auto& elem: insert_rules) {
       10:  144-block  0
       44:  144-block  1
branch  0 taken 44
branch  1 taken 0
       44:  144-block  2
branch  2 taken 34
branch  3 taken 10
       34:  144-block  3
branch  4 taken 34
branch  5 taken 0
       34:  144-block  4
       34:  144-block  5
branch  6 taken 34
branch  7 taken 0
       34:  144-block  6
       34:  145:        transitions[elem.first].insert(elem.second);
       34:  145-block  0
branch  0 taken 34
branch  1 taken 0
       34:  145-block  1
branch  2 taken 34
branch  3 taken 0
        -:  146:    }
       10:  147:}
    $$$$$:  147-block  0
    $$$$$:  147-block  1
    $$$$$:  147-block  2
    $$$$$:  147-block  3
    $$$$$:  147-block  4
       10:  147-block  5
    $$$$$:  147-block  6
    $$$$$:  147-block  7
        -:  148:
        -:  149://deleting long rules
function _ZN7Grammar15fourth_step_CNFEv called 10 returned 0% blocks executed 84%
       10:  150:void Grammar::fourth_step_CNF() {
       10:  150-block  0
       10:  151:    std::set<std::pair<int, std::vector<int>>> insert_rules;
       10:  152:    std::set<std::pair<int, std::vector<int>>> erase_rules;
       10:  153:    int k = 0;
       65:  154:    for(auto& rule: transitions) {
       10:  154-block  0
       65:  154-block  1
branch  0 taken 65
branch  1 taken 0
       65:  154-block  2
branch  2 taken 55
branch  3 taken 10
       55:  154-block  3
branch  4 taken 55
branch  5 taken 0
       55:  154-block  4
       55:  154-block  5
branch  6 taken 55
branch  7 taken 0
       55:  154-block  6
      122:  155:        for(auto& word: rule.second) {
       55:  155-block  0
      122:  155-block  1
branch  0 taken 122
branch  1 taken 0
      122:  155-block  2
branch  2 taken 67
branch  3 taken 55
       67:  155-block  3
branch  4 taken 67
branch  5 taken 0
       20:  155-block  4
       67:  155-block  5
branch  6 taken 67
branch  7 taken 0
       67:  155-block  6
       67:  156:            if(word.size() <= 2 || alpabet.contains(word[0])) {
       67:  156-block  0
branch  0 taken 47
branch  1 taken 20
       20:  156-block  1
branch  2 taken 20
branch  3 taken 0
       20:  156-block  2
branch  4 taken 0
branch  5 taken 20
       47:  157:                continue;
       47:  157-block  0
        -:  158:            }
       20:  159:            int cur_nonterm = rule.first;
       20:  160:            std::vector<int> new_word = word;
       20:  160-block  0
branch  0 taken 20
branch  1 taken 0
       44:  161:            for(long long i = word.size() - 1; i > 1; --i) {
       20:  161-block  0
       44:  161-block  1
branch  0 taken 24
branch  1 taken 20
       24:  161-block  2
       24:  162:                int new_nonterm = std::max(*(alpabet.rbegin()) + 1 + i + k, *(nonterminals.rbegin()) + 1 + i + k);
       24:  162-block  0
branch  0 taken 24
branch  1 taken 0
       24:  162-block  1
branch  2 taken 24
branch  3 taken 0
       24:  162-block  2
branch  4 taken 24
branch  5 taken 0
       24:  163:                std::vector<int> new_right_word = {new_nonterm, word[i]};
       24:  163-block  0
branch  0 taken 24
branch  1 taken 0
       24:  164:                insert_rules.insert({cur_nonterm, new_right_word});
       24:  164-block  0
branch  0 taken 24
branch  1 taken 0
       24:  164-block  1
branch  2 taken 24
branch  3 taken 0
    $$$$$:  164-block  2
       24:  165:                erase_rules.insert({cur_nonterm, new_word});
       24:  165-block  0
branch  0 taken 24
branch  1 taken 0
       24:  165-block  1
branch  2 taken 24
branch  3 taken 0
    $$$$$:  165-block  2
       24:  166:                new_word.pop_back();
       24:  166-block  0
branch  0 taken 24
branch  1 taken 0
       24:  167:                insert_rules.insert({new_nonterm, new_word});
       24:  167-block  0
branch  0 taken 24
branch  1 taken 0
       24:  167-block  1
branch  2 taken 24
branch  3 taken 0
    $$$$$:  167-block  2
       24:  168:                cur_nonterm = new_nonterm;
       24:  169:            }
       24:  169-block  0
    $$$$$:  169-block  1
       20:  170:            ++k;
       20:  171:        }
    $$$$$:  171-block  0
       55:  172:        ++k;
        -:  173:    }
       58:  174:    for(auto& elem: insert_rules) {
       10:  174-block  0
       58:  174-block  1
branch  0 taken 58
branch  1 taken 0
       58:  174-block  2
branch  2 taken 48
branch  3 taken 10
       48:  174-block  3
branch  4 taken 48
branch  5 taken 0
       48:  174-block  4
       48:  174-block  5
branch  6 taken 48
branch  7 taken 0
       48:  174-block  6
       48:  175:        transitions[elem.first].insert(elem.second);
       48:  175-block  0
branch  0 taken 48
branch  1 taken 0
       48:  175-block  1
branch  2 taken 48
branch  3 taken 0
       48:  176:        nonterminals.insert(elem.first);
       48:  176-block  0
branch  0 taken 48
branch  1 taken 0
        -:  177:    }
       34:  178:    for(auto& elem: erase_rules) {
       10:  178-block  0
       34:  178-block  1
branch  0 taken 34
branch  1 taken 0
       34:  178-block  2
branch  2 taken 24
branch  3 taken 10
       24:  178-block  3
branch  4 taken 24
branch  5 taken 0
       24:  178-block  4
       24:  178-block  5
branch  6 taken 24
branch  7 taken 0
       24:  178-block  6
       24:  179:        transitions[elem.first].erase(elem.second);
       24:  179-block  0
branch  0 taken 24
branch  1 taken 0
       24:  179-block  1
branch  2 taken 24
branch  3 taken 0
        -:  180:    }
       10:  181:}
    $$$$$:  181-block  0
    $$$$$:  181-block  1
    $$$$$:  181-block  2
       10:  181-block  3
    $$$$$:  181-block  4
    $$$$$:  181-block  5
        -:  182:
function _ZN7Grammar24is_conclusion_empty_wordEi called 128 returned 100% blocks executed 72%
      128:  183:bool Grammar::is_conclusion_empty_word(int nonterm) {
      128:  183-block  0
      128:  184:    if(!nonterminals.contains(nonterm)) {
      128:  184-block  0
branch  0 taken 128
branch  1 taken 0
    #####:  185:        return false;
    $$$$$:  185-block  0
        -:  186:    }
      238:  187:    for(auto& word: transitions[nonterm]) {
      128:  187-block  0
      238:  187-block  1
branch  0 taken 134
branch  1 taken 104
      110:  187-block  2
      110:  187-block  3
      134:  188:        if(word.size() == 1) {
      134:  188-block  0
branch  0 taken 94
branch  1 taken 40
       94:  189:            if((alpabet.contains(word[0]) && word[0] == eps)
       94:  189-block  0
branch  0 taken 94
branch  1 taken 0
    $$$$$:  189-block  1
branch  2 never executed
branch  3 never executed
       94:  190:                || (nonterminals.contains(word[0]) && word[0] != nonterm
       94:  190-block  0
branch  0 taken 24
branch  1 taken 70
       70:  190-block  1
branch  2 taken 0
branch  3 taken 70
    #####:  191:                    && is_conclusion_empty_word(word[0]))) {
    $$$$$:  191-block  0
branch  0 never executed
branch  1 never executed
       24:  192:                return true;
       24:  192-block  0
        -:  193:            }
       70:  194:        }
       70:  194-block  0
      110:  195:        if(word.size() == 2) {
      110:  195-block  0
branch  0 taken 40
branch  1 taken 70
       40:  196:            if(alpabet.contains(word[0]) && word[0] == word[1] && word[0] == eps) {
       40:  196-block  0
branch  0 taken 0
branch  1 taken 40
    $$$$$:  196-block  1
branch  2 never executed
branch  3 never executed
    $$$$$:  196-block  2
branch  4 never executed
branch  5 never executed
    #####:  197:                return true;
    $$$$$:  197-block  0
        -:  198:            }
       40:  199:            if(nonterminals.contains(word[0]) && word[0] != nonterm && word[1] != nonterm
       40:  199-block  0
branch  0 taken 40
branch  1 taken 0
       40:  199-block  1
branch  2 taken 40
branch  3 taken 0
    $$$$$:  199-block  2
branch  4 never executed
branch  5 never executed
       40:  200:                && is_conclusion_empty_word(word[0]) && is_conclusion_empty_word(word[1])) {
       40:  200-block  0
branch  0 taken 40
branch  1 taken 0
       40:  200-block  1
branch  2 taken 0
branch  3 taken 40
    #####:  201:                return true;
    $$$$$:  201-block  0
        -:  202:            }
       40:  203:        }
       40:  203-block  0
        -:  204:    }
      104:  205:    return false;
      104:  205-block  0
      128:  206:}
      128:  206-block  0
        -:  207:
        -:  208://deleting eps generating symbols
function _ZN7Grammar14fifth_step_CNFEv called 10 returned 0% blocks executed 73%
       10:  209:void Grammar::fifth_step_CNF() {
       10:  209-block  0
       10:  210:    std::set<std::pair<int, std::vector<int>>> insert_rules;
       89:  211:    for(auto& rule: transitions) {
       10:  211-block  0
       89:  211-block  1
branch  0 taken 89
branch  1 taken 0
       89:  211-block  2
branch  2 taken 79
branch  3 taken 10
       79:  211-block  3
branch  4 taken 79
branch  5 taken 0
       79:  211-block  4
       79:  211-block  5
branch  6 taken 79
branch  7 taken 0
       79:  211-block  6
      170:  212:        for(auto& word: rule.second) {
       79:  212-block  0
      170:  212-block  1
branch  0 taken 170
branch  1 taken 0
      170:  212-block  2
branch  2 taken 91
branch  3 taken 79
       91:  212-block  3
branch  4 taken 91
branch  5 taken 0
       44:  212-block  4
       91:  212-block  5
branch  6 taken 91
branch  7 taken 0
       91:  212-block  6
       91:  213:            if(word.size() != 2) {
       91:  213-block  0
branch  0 taken 47
branch  1 taken 44
       47:  214:                continue;
       47:  214-block  0
        -:  215:            }
       44:  216:            if(is_conclusion_empty_word(word[1])) {
       44:  216-block  0
branch  0 taken 44
branch  1 taken 0
       44:  216-block  1
branch  2 taken 24
branch  3 taken 20
       24:  217:                std::vector<int> new_right_word = {word[0]};
       24:  217-block  0
branch  0 taken 24
branch  1 taken 0
       24:  218:                insert_rules.insert({rule.first, new_right_word});
       24:  218-block  0
branch  0 taken 24
branch  1 taken 0
       24:  218-block  1
branch  2 taken 24
branch  3 taken 0
    $$$$$:  218-block  2
       24:  219:            }
       24:  219-block  0
    $$$$$:  219-block  1
       44:  220:            if(is_conclusion_empty_word(word[0])) {
       44:  220-block  0
branch  0 taken 44
branch  1 taken 0
       44:  220-block  1
branch  2 taken 0
branch  3 taken 44
    #####:  221:                std::vector<int> new_right_word = {word[1]};
    $$$$$:  221-block  0
branch  0 never executed
branch  1 never executed
    #####:  222:                insert_rules.insert({rule.first, new_right_word});
    $$$$$:  222-block  0
branch  0 never executed
branch  1 never executed
    $$$$$:  222-block  1
branch  2 never executed
branch  3 never executed
    $$$$$:  222-block  2
    #####:  223:            }
    $$$$$:  223-block  0
    $$$$$:  223-block  1
        -:  224:        }
        -:  225:    }
       34:  226:    for(auto& elem: insert_rules) {
       10:  226-block  0
       34:  226-block  1
branch  0 taken 34
branch  1 taken 0
       34:  226-block  2
branch  2 taken 24
branch  3 taken 10
       24:  226-block  3
branch  4 taken 24
branch  5 taken 0
       24:  226-block  4
       24:  226-block  5
branch  6 taken 24
branch  7 taken 0
       24:  226-block  6
       24:  227:        transitions[elem.first].insert(elem.second);
       24:  227-block  0
branch  0 taken 24
branch  1 taken 0
       24:  227-block  1
branch  2 taken 24
branch  3 taken 0
        -:  228:    }
       10:  229:    del_empty_word_rules();
       10:  229-block  0
branch  0 taken 10
branch  1 taken 0
       10:  230:}
    $$$$$:  230-block  0
    $$$$$:  230-block  1
    $$$$$:  230-block  2
       10:  230-block  3
    $$$$$:  230-block  4
    $$$$$:  230-block  5
        -:  231:
function _ZN7Grammar20del_empty_word_rulesEv called 10 returned 0% blocks executed 72%
       10:  232:void Grammar::del_empty_word_rules() {
       10:  232-block  0
       88:  233:    for(auto nonterm: nonterminals) {
       10:  233-block  0
       88:  233-block  1
branch  0 taken 78
branch  1 taken 10
       78:  233-block  2
       78:  233-block  3
       78:  234:        transitions[nonterm].erase({eps});
       78:  234-block  0
branch  0 taken 78
branch  1 taken 0
    $$$$$:  234-block  1
    $$$$$:  234-block  2
       78:  235:        transitions[nonterm].erase({eps, eps});
       78:  235-block  0
branch  0 taken 78
branch  1 taken 0
    $$$$$:  235-block  1
        -:  236:    }
       10:  237:}
       10:  237-block  0
        -:  238:
function _ZN7Grammar14sixth_step_CNFEv called 10 returned 0% blocks executed 71%
       10:  239:void Grammar::sixth_step_CNF() {
       10:  239-block  0
       10:  240:    if(is_conclusion_eps) {
       10:  240-block  0
branch  0 taken 3
branch  1 taken 7
        3:  241:        transitions[start].insert({eps});
        3:  241-block  0
branch  0 taken 3
branch  1 taken 0
    $$$$$:  241-block  1
    $$$$$:  241-block  2
        3:  242:    }
        3:  242-block  0
       10:  243:}
       10:  243-block  0
        -:  244:
        -:  245://deleting unary rules
function _ZN7Grammar16seventh_step_CNFEv called 10 returned 0% blocks executed 88%
       10:  246:void Grammar::seventh_step_CNF() {
       10:  246-block  0
       10:  247:    std::set<std::pair<int, std::vector<int>>> insert_rules;
       10:  248:    std::set<std::pair<int, std::vector<int>>> erase_rules;
       89:  249:    for(auto& rule: transitions) {
       10:  249-block  0
       89:  249-block  1
branch  0 taken 89
branch  1 taken 0
       89:  249-block  2
branch  2 taken 79
branch  3 taken 10
       79:  249-block  3
branch  4 taken 79
branch  5 taken 0
       79:  249-block  4
       79:  249-block  5
branch  6 taken 79
branch  7 taken 0
       79:  249-block  6
      189:  250:        for(auto& word: rule.second) {
       79:  250-block  0
      189:  250-block  1
branch  0 taken 189
branch  1 taken 0
      189:  250-block  2
branch  2 taken 110
branch  3 taken 79
      110:  250-block  3
branch  4 taken 110
branch  5 taken 0
      110:  250-block  4
      110:  250-block  5
branch  6 taken 110
branch  7 taken 0
      110:  250-block  6
      110:  251:            if(word.size() == 1 && !alpabet.contains(word[0])) {
      110:  251-block  0
branch  0 taken 66
branch  1 taken 44
       66:  251-block  1
branch  2 taken 66
branch  3 taken 0
       66:  251-block  2
branch  4 taken 42
branch  5 taken 24
       24:  252:                erase_rules.insert({rule.first, word});
       24:  252-block  0
branch  0 taken 24
branch  1 taken 0
       24:  252-block  1
branch  2 taken 24
branch  3 taken 0
    $$$$$:  252-block  2
       24:  253:                std::queue<int> q;
       24:  254:                q.push(word[0]);
       24:  254-block  0
branch  0 taken 24
branch  1 taken 0
       54:  255:                while(!q.empty()) {
       24:  255-block  0
       54:  255-block  1
branch  0 taken 54
branch  1 taken 0
       54:  255-block  2
branch  2 taken 30
branch  3 taken 24
       30:  255-block  3
       30:  256:                    int nonterm = q.front();
       30:  256-block  0
branch  0 taken 30
branch  1 taken 0
       30:  257:                    q.pop();
       30:  257-block  0
branch  0 taken 30
branch  1 taken 0
       66:  258:                    for(auto& new_word: transitions[nonterm]) {
       30:  258-block  0
branch  0 taken 30
branch  1 taken 0
       30:  258-block  1
       66:  258-block  2
branch  2 taken 66
branch  3 taken 0
       66:  258-block  3
branch  4 taken 36
branch  5 taken 30
       36:  258-block  4
branch  6 taken 36
branch  7 taken 0
       36:  258-block  5
       36:  258-block  6
branch  8 taken 36
branch  9 taken 0
       36:  258-block  7
       36:  259:                        if(new_word.size() == 1 && !alpabet.contains(new_word[0])) {
       36:  259-block  0
branch  0 taken 28
branch  1 taken 8
       28:  259-block  1
branch  2 taken 28
branch  3 taken 0
       28:  259-block  2
branch  4 taken 22
branch  5 taken 6
        6:  260:                            if(new_word[0] == nonterm) {
        6:  260-block  0
branch  0 taken 0
branch  1 taken 6
    #####:  261:                                continue;
    $$$$$:  261-block  0
        -:  262:                            }
        6:  263:                            q.push(new_word[0]);
        6:  263-block  0
branch  0 taken 6
branch  1 taken 0
        6:  264:                        } else {
        6:  264-block  0
       30:  265:                            insert_rules.insert({rule.first, new_word});
       30:  265-block  0
branch  0 taken 30
branch  1 taken 0
       30:  265-block  1
branch  2 taken 30
branch  3 taken 0
       30:  265-block  2
    $$$$$:  265-block  3
        -:  266:                        }
        -:  267:                    }
        -:  268:                }
       24:  269:            }
       24:  269-block  0
    $$$$$:  269-block  1
        -:  270:        }
        -:  271:    }
       40:  272:    for(auto& elem: insert_rules) {
       10:  272-block  0
       40:  272-block  1
branch  0 taken 40
branch  1 taken 0
       40:  272-block  2
branch  2 taken 30
branch  3 taken 10
       30:  272-block  3
branch  4 taken 30
branch  5 taken 0
       30:  272-block  4
       30:  272-block  5
branch  6 taken 30
branch  7 taken 0
       30:  272-block  6
       30:  273:        transitions[elem.first].insert(elem.second);
       30:  273-block  0
branch  0 taken 30
branch  1 taken 0
       30:  273-block  1
branch  2 taken 30
branch  3 taken 0
        -:  274:    }
       34:  275:    for(auto& elem: erase_rules) {
       10:  275-block  0
       34:  275-block  1
branch  0 taken 34
branch  1 taken 0
       34:  275-block  2
branch  2 taken 24
branch  3 taken 10
       24:  275-block  3
branch  4 taken 24
branch  5 taken 0
       24:  275-block  4
       24:  275-block  5
branch  6 taken 24
branch  7 taken 0
       24:  275-block  6
       24:  276:        transitions[elem.first].erase(elem.second);
       24:  276-block  0
branch  0 taken 24
branch  1 taken 0
       24:  276-block  1
branch  2 taken 24
branch  3 taken 0
        -:  277:    }
       10:  278:}
    $$$$$:  278-block  0
    $$$$$:  278-block  1
       10:  278-block  2
    $$$$$:  278-block  3
    $$$$$:  278-block  4
        -:  279:
function _ZN7Grammar6to_CNFEv called 10 returned 100% blocks executed 100%
       10:  280:void Grammar::to_CNF() {
       10:  280-block  0
       10:  281:    first_step_CNF();
       10:  282:    second_step_CNF();
       10:  283:    third_step_CNF();
       10:  284:    fourth_step_CNF();
       10:  285:    fifth_step_CNF();
       10:  286:    sixth_step_CNF();
       10:  287:    seventh_step_CNF();
       10:  288:}
       10:  288-block  0
        -:  289:
        -:  290://void Grammar::add_transition(int from, std::set<std::string>& to) {
        -:  291://    nonterminals.insert(from);
        -:  292://    std::vector<int> new_right_word;
        -:  293://    for(auto& word: to) {
        -:  294://        for(int i = 0; i < word.size(); ++i) {
        -:  295://            alpabet.insert(word[i]);
        -:  296://            new_right_word.push_back((int)word[i]);
        -:  297://        }
        -:  298://        transitions[from].insert(new_right_word);
        -:  299://    }
        -:  300://}
        -:  301:
